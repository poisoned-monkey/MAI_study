# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Кузьмичев А.Н.

## Результат проверки

| Преподаватель | Дата | Оценка |
|-------------------|--------------|---------------|
| Сошников Д.В. | | |
| Левинская М.А.| | |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

Список в прологе - упорядоченная последовательность элементов, которая может иметь произвольную длину, причем порядок элементов в последовательности является существенным; при работе со списками не указывается конкретный тип данных внутри него, однако необходимо, чтобы все элементы списка имели единый тип - элементами списка могут быть любые термы – константы, переменные, структуры (те же списки).

Списки похожи на такие традиционные структуры данных, как массив, вектор и, естественно, они похожи на списки, реализуемые в императивных языках программирования. Однако списки в языке Пролог все же имеют отличия от привычных подходов хранения данных в других языках: список в Прологе не требует декларирования размера и типа данных его элементов до начала использования; кроме того, Пролог способен обособлять первый элемент списка (голову) и все остальные элементы (хвост).

## Задание 1.1: Предикат обработки списка

list_next(Elem , List, NextElem) - предикат получения следющего элемента после заданного

Примеры использования:

?- list_next(1, [1,2,3], Elem).
Elem = 2 ;
false.
?- list_next(1, [1,2,1], Elem).
Elem = 2 ;
false.
?- list_next(1, [1,2,1,5], Elem).
Elem = 2 ;
Elem = 5 ;
false.
Реализация:

list_next(Elem , List, NextElem):-
list_append(_,[Elem, NextElem|_], List).

list_next_s(Elem, List, NextElem):-
append(_, [Elem,NextElem|_], List).

Способ нахождения предиката прост - проверить все вхождения, когда из двух других списков, причем у второго после заданного элемента следует искомый, можем получить в процессе конкатенации заданный список. Как для реализации через стандартные функции, так и для своей реализации я использовал предикат соединения двух списков.

## Задание 2: Реляционное представление данных

Преимущества реляционного представления заключается в удобном поиске необходимой информации, такое представление отображает информацию в наиболее простой для пользователя форме, позволяет легко добавлять новую и удалять ненужную информацию. Однако есть и недостатки: довольно медленный доступ к данным (он удобен с точки зрения понимания места поиска, но иногда занимает много времени), а также возможные трудности, возникающие при работе с огромными размерами информации (слишком большие таблицы). В частности, мое представление данных не совсем удобно, так как записей очень много, и к тому же искать определенную информацию является затруднительным (например, чтобы посмотреть оценки студентов определенной группы, нужно помнить, к какой группе принадлежит студент, ведь факт grade не отображает этой информации).

В первом пункте требуется получить таблицу групп и средний балл по каждой из групп: Я реализовал предикат group(Group,L), который при помощи стандартного предиката findall ищет в базе данных нужные записи и записывает всех студентов группы в отдельный список. Также я реализовал предикат group_table(T), который принимает список номеров групп и также при помощи findall находит всех студентов для каждой группы, однако теперь при помощи стандартного предикакта asserta в базу данных добавляется факт group(Group,L), а пользователю выводятся номера всех групп и соответствующие списки студентов. Для нахождения среднего балла по группе я реализовал предикат avg_grade(Group,N), который при помощи bagof (тот же findall, но при пустом списке выдает неуспех) ищет в базе данных количество получений каждой оценки в группе - делается это при помощи предиката gradeN_student(N,Name,Group); затем на основе полученных данных вычисляется сумма баллов (длина каждого списка, умноженная на значение оценки) и делится на общее количество оценок (сумма
длин всех списков с оценками). Этот результат и будет средним баллом группы.

Во втором пункте требуется для каждого предмета получить список студентов, не сдавших экзамен. Делается это легко при помощи единственного предиката notpassed_sub_list(Subject,L), который использует bagof для нахождения имен студентов, для которых имеется факт получения двойки по данному предмету grade(X,Subject,2).

В третьем пункте требуется найти количество не сдавших студентов в каждой из групп. Для этого реализован предикат n_of_notpassed(Group,N), который при помощи предиката setof (в отличии от findall и bagof получает отсортированный список без повторений элементов) получает список студентов, удовлетворяющих предикату notpassed_student(Name,Group), то есть получивших двойку и находящихся в данной группе, а затем вычисляет длину этого списка, что и является ответом.

## Выводы

Данная лабораторная работа в целом позволяет ознакомится с базовыми возможностями языка Prolog, учит работе со списками и стандартными база данными. В ходе выполнения с заданиями столкнулся с рядом проблем – сначала было сложно понять по каким правилам работают декларативные языки, но позже, с пониманием его основных принципов становятся очевидны плюсы данных языков – отсутствие типизации значений, удобные в обращении списки и крайне удобная обработка баз данных, заданными специальными предикатами, в целом могу сказать, что Prolog может быть применим для решения ряда специфических задач.
